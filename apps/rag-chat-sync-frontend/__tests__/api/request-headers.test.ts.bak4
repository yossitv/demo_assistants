/**
 * Property-based tests for API request headers
 * Test Property 22: API request headers (validates Requirement 7.3)
 *
 * Requirement 7.3: All API requests must include Authorization header with JWT token
 * and Content-Type header must be set correctly for POST requests
 */

import * as fc from 'fast-check';
import { ApiClient } from '@/lib/api/client';

// Mock global fetch
global.fetch = jest.fn();

describe('Property 22: API Request Headers', () => {
  let apiClient: ApiClient;
  let mockFetch: jest.MockedFunction<typeof fetch>;
  let originalEnv: NodeJS.ProcessEnv;

  beforeEach(() => {
    // Save and clear environment variables that might interfere
    originalEnv = process.env;
    process.env = { ...originalEnv };
    delete process.env.NEXT_PUBLIC_JWT_TOKEN;
    delete process.env.NEXT_PUBLIC_API_BASE_URL;

    // Reset all mocks before each test
    jest.clearAllMocks();
    mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;

    // Setup default successful response
    mockFetch.mockResolvedValue({
      ok: true,
      status: 200,
      statusText: 'OK',
      headers: new Headers({ 'content-type': 'application/json' }),
      json: async () => ({ success: true }),
      text: async () => '{"success":true}',
    } as Response);
  });

  afterEach(() => {
    // Restore original environment
    process.env = originalEnv;
  });

  describe('Authorization Header Tests', () => {
    it('Property: All API requests include Authorization header with JWT token', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }), // JWT token (hex to avoid special chars)
          async (jwtToken) => {
            // Create client with token
            apiClient = new ApiClient({ jwtToken });

            // Make request
            try {
              await apiClient.chat('agent-123', 'test message');
            } catch {
              // Ignore errors, we're only testing headers
            }

            // Verify fetch was called
            expect(mockFetch).toHaveBeenCalled();

            // Get the headers from the fetch call
            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify Authorization header is present
            expect(headers['Authorization']).toBeDefined();
            expect(headers['Authorization']).toBe(`Bearer ${jwtToken}`);
          }
        ),
        { numRuns: 50 }
      );
    });

    it('Property: Authorization header format is always "Bearer <token>"', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 10, maxLength: 500 }),
          async (token) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify format
            expect(headers['Authorization']).toMatch(/^Bearer .+$/);
            expect(headers['Authorization']).toBe(`Bearer ${token}`);
          }
        ),
        { numRuns: 50 }
      );
    });

    it('Property: Authorization header persists across multiple requests', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.nat({ max: 10 }), // number of requests
          async (token, numRequests) => {
            fc.pre(numRequests > 0); // Ensure at least one request

            apiClient = new ApiClient({ jwtToken: token });

            // Make multiple requests
            for (let i = 0; i < numRequests; i++) {
              try {
                await apiClient.listKnowledgeSpaces();
              } catch {
                // Ignore errors
              }
            }

            // Verify all requests have the same Authorization header
            expect(mockFetch).toHaveBeenCalledTimes(numRequests);

            for (let i = 0; i < numRequests; i++) {
              const callArgs = mockFetch.mock.calls[i];
              const requestInit = callArgs[1] as RequestInit;
              const headers = requestInit.headers as Record<string, string>;

              expect(headers['Authorization']).toBe(`Bearer ${token}`);
            }
          }
        ),
        { numRuns: 30 }
      );
    });

    it('Property: Token can be updated and subsequent requests use new token', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.base64String({ minLength: 20, maxLength: 200 }),
          async (initialToken, newToken) => {
            fc.pre(initialToken !== newToken); // Ensure tokens are different

            apiClient = new ApiClient({ jwtToken: initialToken });

            // First request with initial token
            try {
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            // Update token
            apiClient.setToken(newToken);

            // Second request with new token
            try {
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            // Verify first request used initial token
            const firstCall = mockFetch.mock.calls[0];
            const firstHeaders = firstCall[1]?.headers as Record<string, string>;
            expect(firstHeaders['Authorization']).toBe(`Bearer ${initialToken}`);

            // Verify second request used new token
            const secondCall = mockFetch.mock.calls[1];
            const secondHeaders = secondCall[1]?.headers as Record<string, string>;
            expect(secondHeaders['Authorization']).toBe(`Bearer ${newToken}`);
          }
        ),
        { numRuns: 30 }
      );
    });
  });

  describe('Content-Type Header Tests for POST Requests', () => {
    it('Property: All POST requests include Content-Type: application/json header', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.record({
            message: fc.string({ minLength: 1, maxLength: 500 }),
            agentId: fc.string({ minLength: 1, maxLength: 100 }),
          }),
          async (token, requestData) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.chat(requestData.agentId, requestData.message);
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify Content-Type header
            expect(headers['Content-Type']).toBe('application/json');
          }
        ),
        { numRuns: 50 }
      );
    });

    it('Property: POST request bodies are valid JSON strings', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.record({
            name: fc.string({ minLength: 1, maxLength: 100 }),
            description: fc.string({ minLength: 1, maxLength: 500 }),
            knowledgeSpaceId: fc.string({ minLength: 1, maxLength: 100 }),
          }),
          async (token, agentData) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.createAgent(
                agentData.knowledgeSpaceId,
                agentData.name,
                agentData.description
              );
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const body = requestInit.body as string;

            // Verify body is valid JSON
            expect(() => JSON.parse(body)).not.toThrow();

            // Verify parsed body contains expected data
            const parsedBody = JSON.parse(body);
            expect(parsedBody.name).toBe(agentData.name.trim());
            expect(parsedBody.description).toBe(agentData.description.trim());
          }
        ),
        { numRuns: 50 }
      );
    });

    it('Property: All POST requests with body have both Authorization and Content-Type headers', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.record({
            name: fc.string({ minLength: 1, maxLength: 100 }),
            urls: fc.array(fc.webUrl(), { minLength: 1, maxLength: 5 }),
          }),
          async (token, ksData) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.createKnowledgeSpace(ksData.name, ksData.urls);
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify both headers are present
            expect(headers['Authorization']).toBeDefined();
            expect(headers['Authorization']).toBe(`Bearer ${token}`);
            expect(headers['Content-Type']).toBe('application/json');
          }
        ),
        { numRuns: 50 }
      );
    });
  });

  describe('HTTP Method Tests', () => {
    it('Property: GET requests include Authorization but may not include Content-Type', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          async (token) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify Authorization is present
            expect(headers['Authorization']).toBe(`Bearer ${token}`);

            // Verify method is GET
            expect(requestInit.method).toBe('GET');
          }
        ),
        { numRuns: 30 }
      );
    });

    it('Property: DELETE requests include Authorization header', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.string({ minLength: 1, maxLength: 100 }),
          async (token, agentId) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.deleteAgent(agentId.trim());
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify Authorization is present
            expect(headers['Authorization']).toBe(`Bearer ${token}`);

            // Verify method is DELETE
            expect(requestInit.method).toBe('DELETE');
          }
        ),
        { numRuns: 30 }
      );
    });
  });

  describe('Edge Cases', () => {
    it('Property: Empty token string results in no Authorization header', () => {
      fc.assert(
        fc.property(
          fc.constant(''), // empty token
          async (token) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Empty token means no Authorization header (falsy check in client)
            expect(headers['Authorization']).toBeUndefined();
          }
        ),
        { numRuns: 10 }
      );
    });

    it('Property: Special characters in token are preserved', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }).map(s =>
            s + '!@#$%^&*()_+-=[]{}|;:,.<>?'
          ),
          async (token) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify token is exactly as provided
            expect(headers['Authorization']).toBe(`Bearer ${token}`);
          }
        ),
        { numRuns: 30 }
      );
    });

    it('Property: Token with whitespace is preserved exactly', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 10, maxLength: 50 }),
          fc.base64String({ minLength: 10, maxLength: 50 }),
          async (part1, part2) => {
            const token = `${part1}   ${part2}`; // Token with spaces

            apiClient = new ApiClient({ jwtToken: token });

            try{
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Verify whitespace is preserved
            expect(headers['Authorization']).toBe(`Bearer ${token}`);
          }
        ),
        { numRuns: 30 }
      );
    });
  });

  describe('Header Invariants', () => {
    it('Property: Headers object is always defined for all requests', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.oneof(
            fc.constant('GET'),
            fc.constant('POST'),
            fc.constant('DELETE')
          ),
          async (token, method) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              if (method === 'GET') {
                await apiClient.listKnowledgeSpaces();
              } else if (method === 'POST') {
                await apiClient.chat('agent-1', 'test');
              } else if (method === 'DELETE') {
                await apiClient.deleteAgent('agent-1');
              }
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;

            // Headers should always be defined
            expect(requestInit.headers).toBeDefined();
            expect(typeof requestInit.headers).toBe('object');
          }
        ),
        { numRuns: 50 }
      );
    });

    it('Property: Authorization header is never undefined when token is set', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 1, maxLength: 500 }),
          async (token) => {
            apiClient = new ApiClient({ jwtToken: token });

            try {
              await apiClient.listKnowledgeSpaces();
            } catch {
              // Ignore errors
            }

            const callArgs = mockFetch.mock.calls[0];
            const requestInit = callArgs[1] as RequestInit;
            const headers = requestInit.headers as Record<string, string>;

            // Authorization should never be undefined
            expect(headers['Authorization']).toBeDefined();
            expect(headers['Authorization']).not.toBe('');
            expect(headers['Authorization']).not.toBeNull();
            expect(headers['Authorization']).not.toBeUndefined();
          }
        ),
        { numRuns: 50 }
      );
    });

    it('Property: Content-Type header is consistent across all POST requests', () => {
      fc.assert(
        fc.property(
          fc.base64String({ minLength: 20, maxLength: 200 }),
          fc.nat({ max: 5 }),
          async (token, numPosts) => {
            fc.pre(numPosts > 0);

            apiClient = new ApiClient({ jwtToken: token });

            // Make multiple POST requests
            for (let i = 0; i < numPosts; i++) {
              try {
                await apiClient.chat(`agent-${i}`, `message-${i}`);
              } catch {
                // Ignore errors
              }
            }

            // Verify all POST requests have the same Content-Type
            const contentTypes = new Set<string>();
            for (let i = 0; i < numPosts; i++) {
              const callArgs = mockFetch.mock.calls[i];
              const requestInit = callArgs[1] as RequestInit;
              const headers = requestInit.headers as Record<string, string>;
              contentTypes.add(headers['Content-Type']);
            }

            // All should be the same
            expect(contentTypes.size).toBe(1);
            expect(contentTypes.has('application/json')).toBe(true);
          }
        ),
        { numRuns: 30 }
      );
    });
  });
});
